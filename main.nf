#!/usr/bin/env nextflow

nextflow.enable.dsl = 2 

/*
========================================================================================
                         crisprSNF
========================================================================================
 Analysis Pipeline.
 #### Homepage / Documentation
 https://github.com/
----------------------------------------------------------------------------------------
*/

def helpMessage() {
    log.info nfcoreHeader()
    log.info"""
    Usage:
      nextflow run /hpcnfs/data/GN2/fgualdrini/tools/NEXTFLOW_PIPES/crisprSNF --input design.csv --genome GRCh37 -profile singularity
    Mandatory arguments:
      --input [file]                  Comma-separated file containing information about the samples in the experiment (see docs/usage.md) (Default: './design.csv')
      --fasta [file]                  Path to Fasta reference. Not mandatory when using reference in iGenomes config via --genome (Default: false)
      -profile [str]                  Configuration profile to use. Can use multiple (comma separated)
                                      Available: conda, docker, singularity, awsbatch, test
    Other
      --outdir [file]                 The output directory where the results will be saved (Default: './results')
      --publish_dir_mode [str]        Mode for publishing results in the output directory. Available: symlink, rellink, link, copy, copyNoFollow, move (Default: copy)
      --email [email]                 Set this parameter to your e-mail address to get a summary e-mail with details of the run sent to you when the workflow exits (Default: false)
      --email_on_fail [email]         Same as --email, except only send mail if the workflow is not successful (Default: false)
      --max_multiqc_email_size [str]  Threshold size for MultiQC report to be attached in notification email. If file generated by pipeline exceeds the threshold, it will not be attached (Default: 25MB)
      -name [str]                     Name for the pipeline run. If not specified, Nextflow will automatically generate a random mnemonic (Default: false)
    """.stripIndent()
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/* --                                                                     -- */
/* --                SET UP CONFIGURATION VARIABLES                       -- */
/* --                                                                     -- */
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Show help message
if (params.help) {
    helpMessage()
    exit 0
}

// Has the run name been specified by the user?
// this has the bonus effect of catching both -name and --name
custom_runName = params.name
if (!(workflow.runName ==~ /[a-z]+_[a-z]+/)) {
    custom_runName = workflow.runName
}

params.input = '/hpcnfs/data/GN2/fgualdrini/Master_batch_scripts/INUTILOMA/Library_testing/Sample_sheet.csv'
if (params.input)     { ch_input = file(params.input, checkIfExists: true) } else { exit 1, 'Samples design file not specified!' }

params.outdir = '/hpcnfs/data/GN2/fgualdrini/Master_batch_scripts/INUTILOMA/Library_testing/'
params.publish_dir_mode = 'copy'

println "input $params.input "
println "outdir $params.outdir "
println "publish_dir_mode $params.publish_dir_mode "

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/* --                                                                     -- */
/* --                     PARSE DESIGN FILE                               -- */
/* --                                                                     -- */
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

include { INPUT_CHECK } from './subworkflow/01_input_check' 
include { CONCAT_FASTQ } from './subworkflow/02_cat_fastq'
include { FASTQC_CUTADAP_UMI } from './subworkflow/03_fastqc_cutadap_umi'

workflow CRISPRSNF {

    ch_versions = Channel.empty()

    //
    // STEP 00: index genome files
    //

    // def biotype = params.gencode ? "gene_type" : params.featurecounts_group_type
    // PREPARE_GENOME (
    //     prepareToolIndices,
    //     biotype,
    //     is_aws_igenome

    // )
    // ch_versions = ch_versions.mix(PREPARE_GENOME.out.versions)


    //
    // STEP01: Read in samplesheet, validate and stage input files
    // This step takes as input a comma separated csv file including rid, sid, sample name id, single_paired, the path to the run to use, the input is required and the lanes to use
    // lanes has being included given that occasionally issues associated to sequencer lane might need to be expluded
    //

    INPUT_CHECK (
        ch_input
    )
    .reads
    .map {
        meta, fastq ->
            def meta_clone = meta.clone()
            meta_clone.id = meta_clone.id.split('_')[0..-2].join('_')
            [ meta_clone, fastq ] 
    }
    .groupTuple(by: [0])
    .branch {
        meta, fastq ->
            single  : fastq.size() == 1             // here it refers to single fastq per sample
                return [ meta, fastq.flatten() ]
            multiple: fastq.size() > 1              // here it refers to multiple fastq per sample
                return [ meta, fastq.flatten() ]
    }
    .set { ch_fastq }
    ch_versions = ch_versions.mix(INPUT_CHECK.out.versions)

    ch_versions.view { "value: $it" } 

    //
    // STEP 02: Concatenate FastQ files from same sample if required 
    // Based on the previous step concatenate fastqs per sample
    // 

    CONCAT_FASTQ (
        ch_fastq.multiple
    )
    .reads
    .mix(ch_fastq.single)
    .set { ch_cat_fastq }
    ch_versions = ch_versions.mix(CONCAT_FASTQ.out.versions.first().ifEmpty(null))

    //
    // STEP 03: 
    // Cutadapt 
    // Identify and remove adapter sequence from both R1 and R2.
    // Report identified position
    //

    FASTQC_CUTADAP_UMI (
        ch_cat_fastq
    )
    .reads
    .mix(ch_fastq.single)
    .set { ch_cat_fastq }
    ch_versions = ch_versions.mix(FASTQC_CUTADAP_UMI.out.versions)

    
       

}


workflow {
    CRISPRSNF ()
}